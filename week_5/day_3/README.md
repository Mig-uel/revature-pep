# JDBC/SQL Intermediate

## Cross Join

A `CROSS JOIN`, commonly known as a `CARTESIAN JOIN`, is a type of join in SQL that returns the Cartesian product of two tables. This means that it combines each row from the first table with every row from the second table, resulting in a set of all possible combinations of rows.

If no condition is provided, the result set is generated by multiplying each row from the first table with each row from the second table. This can lead to a large number of rows in the result set, especially if both tables have many rows.

![Cross Join](cross-join.jpg)

**Syntax:**

```sql
SELECT *
FROM table1
CROSS JOIN table2;
```

### Real World Application

`CROSS JOIN` is used when we need to find all possibilities of combining multiple records, where the result set includes every row from each contributing table. This is particularly useful in scenarios such as:

- Generating all possible combinations of products and customers for a marketing campaign.
- Creating a schedule that pairs every employee with every available project.
- Analyzing the impact of different marketing strategies by combining them with various customer segments.

`CROSS JOIN` can also be used to identify missing relationships or gaps in data by generating all possible combinations and then filtering out the existing relationships.

### Implementation

Let's consider a real world example involving an online store. Below, we have two tables `Customers` and `Products`:

**Customers**

| customerId | f_name  | l_name    |
| ---------- | ------- | --------- |
| 1          | Alice   | May       |
| 2          | Bob     | Parker    |
| 3          | Charlie | Chocolate |

**Products**

| productId | productName | price  |
| --------- | ----------- | ------ |
| 101       | Laptop      | 999.99 |
| 102       | Smartphone  | 499.99 |
| 103       | Headphones  | 79.99  |

Let's generate all possible combinations of customers and products using a `CROSS JOIN`.

```sql
-- Cross join to generate all combinations of customers and products
SELECT Customers.CustomerId, Customers.f_name, Customers.l_name,
       Products.productId, Products.productName, Products.price as ProductPrice
FROM Customers
CROSS JOIN Products;
```

In this example, the `Customers` table represents the store's customers, and the `Products` table represents the available products with their prices. The `CROSS JOIN` generates all possible combinations of customers and products, allowing you to see every customer paired with every product.

**OUTPUT**

| customerId | f_name  | l_name    | productId | productName | ProductPrice |
| ---------- | ------- | --------- | --------- | ----------- | ------------ |
| 1          | Alice   | May       | 101       | Laptop      | 999.99       |
| 1          | Alice   | May       | 102       | Smartphone  | 499.99       |
| 1          | Alice   | May       | 103       | Headphones  | 79.99        |
| 2          | Bob     | Parker    | 101       | Laptop      | 999.99       |
| 2          | Bob     | Parker    | 102       | Smartphone  | 499.99       |
| 2          | Bob     | Parker    | 103       | Headphones  | 79.99        |
| 3          | Charlie | Chocolate | 101       | Laptop      | 999.99       |
| 3          | Charlie | Chocolate | 102       | Smartphone  | 499.99       |
| 3          | Charlie | Chocolate | 103       | Headphones  | 79.99        |

This information can be useful because now we can analyze potential sales opportunities, understand customer preferences, and generate comprehensive reports for marketing strategies.

## Self Join

`SELF JOIN` is a type of join in SQL where a table is joined with itself. This is useful when you want to compare rows within the same table or when you need to find relationships between records in the same table.

When performing a `SELF JOIN`, you typically use table aliases to differentiate between the two instances of the same table. This allows you to reference the same table multiple times in a single query.

This type of join is also known as a Unary relationship.

![Self Join](self-join.jpg)

**Syntax**:

```sql
SELECT a.column1, b.column2
FROM table_name a, table_name b
WHERE a.common_field = b.common_field;
```

### Real World Application

Real world use cases include:

- Finding hierarchical relationships, such as employees and their managers within an organization.
- Comparing records within the same table, such as finding duplicate entries or related items.
- Analyzing relationships in social networks, such as friends or followers.

### Implementation

In the following example, we will have one table since a `SELF JOIN` is a type of join wherein the data is coming from the same table.

**Employees**

| employee_id | employee_name        | manager_id |
| ----------- | -------------------- | ---------- |
| 1           | CEO                  | NULL       |
| 2           | Marketing Manager    | 1          |
| 3           | Sales Manager        | 1          |
| 4           | Marketing Specialist | 2          |
| 5           | Sales Representative | 3          |
| 6           | Marketing Intern     | 2          |

Using the records from this table, we would like to retrieve our employees and readable information for each employee's associated manager in the company.

A `SELF JOIN` query will accomplish this task perfectly:

```sql
SELECT e.employee_name AS employee, m.employee_name AS manager
FROM Employees e
JOIN Employees m
ON e.manager_id = m.employee_id
ORDER BY  e.employee_id;
```

We can also execute the same logic but without the `JOIN` keyword:

```sql
SELECT e.employee_name as employee, m.employee_name as manager
FROM Employees e, Employees m
WHERE e.manager_id = m.employee_id
ORDER BY e.employee_id;
```

**OUTPUT**

| employee             | manager           |
| -------------------- | ----------------- |
| Marketing Manager    | CEO               |
| Sales Manager        | CEO               |
| Marketing Specialist | Marketing Manager |
| Sales Representative | Sales Manager     |
| Marketing Intern     | Marketing Manager |

Both examples utilize a `SELF JOIN` to retrieve related data from the same table. However, the CEO record is not returned from the query due to the `NULL` foreign key reference and the behavior of the `SELF JOIN` or a `WHERE` clause. If we require the CEO record to be returned, we can use a `LEFT JOIN` instead of an `INNER JOIN` or a `WHERE` clause.

```sql
SELECT e.employee_name AS employee, m.employee_name AS manager
FROM Employees e
LEFT JOIN Employees m
ON e.manager_id = m.employee_id
ORDER BY e.employee_id;
```

**OUTPUT**

| employee             | manager           |
| -------------------- | ----------------- |
| CEO                  | NULL              |
| Marketing Manager    | CEO               |
| Sales Manager        | CEO               |
| Marketing Specialist | Marketing Manager |
| Sales Representative | Sales Manager     |
| Marketing Intern     | Marketing Manager |

## Set Operators

Set operators in SQL are used to combine the results of two or more `SELECT` statements into a single result set. The most commonly used set operators are:

- `UNION`: Combines the results of two `SELECT` statements and removes duplicate rows from the result set.
- `UNION ALL`: Combines the results of two `SELECT` statements and includes all rows, including duplicates.
- `INTERSECT`: Returns only the rows that are common to both `SELECT` statements.
- `EXCEPT` (or `MINUS` in some databases): Returns the rows from the first `SELECT` statement that are not present in the second `SELECT` statement.

Two important rules to remember when using set operators:

1. Each `SELECT` statement within the set operator must have the same number of columns in the result sets with similar data types.
2. The columns in each `SELECT` statement must be in the same order.

### Real World Application

Set operators are commonly used by developers to perform operations on sets of data. In the context of databases and SQL, set operators are particularly useful for:

- **Data Retrieval and Filtering**:
  - **UNION**: Developers use `UNION` to combine results from multiple tables or queries, especially when they want to eliminate duplicate records. For example, when retrieving a list of unique customers from different regions.
  - **INTERSECT**: The `INTERSECT` operator is useful for finding common records between two datasets, such as identifying customers who have made purchases in both the current and previous years.
  - **EXCEPT (or MINUS in some databases)**: The `EXCEPT` operator(`MINUS` in some databases) is used to find records that exist in one dataset but not in another, such as identifying customers who have not made any purchases in the last month.
- **Data Cleaning and Deduplication**: Set operators, especially `UNION`, are valuable for data cleaning tasks and deduplication. By combining datasets and removing duplicates, developers can ensure that their data is accurate and consistent.
- **Complex Queries**: Set operators enable developers to construct complex queries by combining multiple sets of data. This is useful for generating reports, analytics, and insights from various sources.
- **Optimizing Queries**: Set operators can be used to optimize queries by breaking down complex queries into smaller, more manageable parts. This can improve query performance and make it easier to understand and maintain the code.
- **Logical Operations**: Set operators mimic logical operations on sets, allowing developers to express complex conditions and relationships between datasets in a clear and concise manner. For example, using `INTERSECT` to find commonalities or `EXCEPT` to identify differences between datasets.
- **Data Analysis and Reporting**: In scenarios where developers need to analyze data from different sources or generate reports that involve merging or comparing datasets, set operators provide a convenient way to achieve this.

Set operators, particularly in databases, help developers manipulate and analyze sets of data efficiently, enabling them to perform tasks such as data retrieval, filtering, cleaning, and complex querying.

### Implementation

Let's consider two tables, `businesses` and `sales`, to demonstrate the use of set operators.

**businesses**

| business_id | business_name         |
| ----------- | --------------------- |
| 1           | Fashion Excess Cloths |
| 2           | High Fashion Shoes    |

**sales**

| sale_id | business_id | product_id | quantity | total_amount |
| ------- | ----------- | ---------- | -------- | ------------ | ------ |
| 1       | 1           | 101        | 3        | 300.00       |
| 2       | 1           | 102        | 2        | 200.00       |
| 3       | 2           | 101        | 5        | 500.00       |
| 4       | 2           | 103        | 4        |              | 400.00 |

#### UNION

The SQl `UNION` operator merges the result sets of multiple `SELECT` statements into a single result set, removing duplicate rows. Ensure that the number of columns and their data types match in each `SELECT` statement. For instance, a `SELECT` with 2 columns cannot be combined with a `SELECT` that has 3 columns.

```sql
-- UNION: Get a combined list of all unique products sold across businesses
SELECT product_id
FROM (
  SELECT product_id FROM sales
  WHERE business_id IN (
    SELECT business_id FROM businesses
    UNION
    SELECT product_id FROM sales
  ) as union_results;
)
```

A list of unique product IDs sold across all businesses is returned and duplicates are removed.

The subquery before `UNION` selects the products with the `product_id` of `101`, `102`, and `103` from the `sales` table. The `UNION` operator combines these results, ensuring that each product ID appears only once in the final output.

**OUTPUT**

| product_id |
| ---------- |
| 101        |
| 102        |
| 103        |

If you wanted to include duplicate records, you could use `UNION ALL` instead of `UNION`.

```sql
-- UNION ALL: Get a combined list of all products sold across businesses, including duplicates
SELECT product_id
FROM (
  SELECT product_id FROM sales
  WHERE business_id IN (
    SELECT business_id FROM businesses
    UNION ALL
    SELECT product_id FROM sales
  ) as union_all_results;
)
```

`UNION ALL` differs from `UNION` in that it does not remove duplicate rows. Therefore, if a product appears multiple times in the individual `SELECT` statements, it will appear multiple times in the final result set.

**OUTPUT**

| product_id |
| ---------- |
| 101        |
| 102        |
| 101        |
| 101        |
| 102        |
| 101        |
| 103        |

#### INTERSECT

The SQL `INTERSECT` operator retrieves only the rows that are common to both `SELECT` statements. It returns the intersection of the two result sets, meaning it includes only those rows that appear in both queries. Similar to `UNION`, the number of columns and their data types must match in each `SELECT` statement.

Note: MySQL **does not** support the `INTERSECT` operator. However, you can achieve similar functionality using `INNER JOIN` or `IN` clause. Always refer to your specific database documentation for supported features.

```sql
-- INTERSECT: Get a list of products sold in common by both businesses
SELECT product_id
FROM (
  SELECT product_id FROM sales
  WHERE business_id = 1
  INTERSECT
  SELECT product_id FROM sales
  WHERE business_id = 2
) AS intersect_results;
```

The query retrieves a list of product IDs that are sold by both businesses. The subquery before `INTERSECT` selects the products sold by business with `business_id` 1, and the second subquery selects the products sold by business with `business_id` 2. The `INTERSECT` operator then returns only those product IDs that are present in both result sets.

**OUTPUT**

| product_id |
| ---------- |
| 101        |

#### EXCEPT (or MINUS)

The SQL `EXCEPT` operator (or `MINUS` in some databases) retrieves rows from the first `SELECT` statement that are not present in the second `SELECT` statement. It returns the difference between the two result sets, meaning it includes only those rows that exist in the first query but not in the second. As with other set operators, the number of columns and their data types must match in each `SELECT` statement.

Note: The `MINUS` operator, found in some databases, is functionally equivalent to `EXCEPT`. For example, in PostgreSQL or Oracle, you an replace `EXCEPT` with `MINUS` to achieve the same result. Always refer to your specific database documentation for supported features.

```sql
--  EXCEPT: Get a list of products sold by business 1 but not by business 2
SELECT product_id
FROM (
  SELECT product_id FROM sales
  WHERE business_id = 1
  EXCEPT
  SELECT product_id FROM sales
  WHERE business_id = 2
) AS except_results;
```

The query retrieves a list of product IDs that are sold by business with `business_id` 1 but not by business with `business_id` 2. The subquery before `EXCEPT` selects the products sold by business 1, and the second subquery selects the products sold by business 2. The `EXCEPT` operator then returns only those product IDs that are present in the first result set but not in the second.

**OUTPUT**

| product_id |
| ---------- |
| 102        |

## Views

In SQL, a `VIEW` is a virtual table that is based on the result set of a `SELECT` query. It does not store data itself but provides a way to present data from one or more tables in a structured format. Views can be used to simplify complex queries, enhance security by restricting access to specific columns or rows, and improve code readability.

Views are created for various reasons, such as simplifying complex queries, encapsulating business logic, and providing a layer of security by restricting access to specific data.

Here are key points about views in SQL:

- **Definition**: A view is defined by a `SELECT` statement that specifies the columns and rows to be included in the view.
- **Virtual Table**: A view is not a physical table; it does not store data. Instead, it dynamically retrieves data from the underlying tables whenever it is queried.
- **Simplified Queries**: Views can simplify complex queries by encapsulating the logic in a named structure. This can make it easier to understand and maintain the code.
- **Security**: Views can be used to restrict access to specific columns or rows in a table. Users can be granted permission to access a view without granting direct access to the underlying tables.
- **Abstraction**: Views provide a level of abstraction by hiding the complexity of the underlying table structures. Users can interact with the view without needing to understand the details of the underlying tables.
- **Joining Tables**: Views can be used to join multiple tables together, making it easier to work with related data.
- **Updatable Views**: In some databases, views can be updatable, meaning that changes made to the view can be propagated back to the underlying tables. However, not all views are updatable, and there are restrictions on which views can be updated.

### Real World Application

The decision to use views is often driver by factors such as simplifying complex queries, enhancing security, providing a layer of abstraction, and improving overall system performance. Here are some common scenarios where views are used:

- **Simplifying Complex Queries**: Views can encapsulate complex SQL logic, making it easier for developers to write and maintain queries. For example, a view can be created to join multiple tables and present a simplified interface for querying customer orders.
- **Abstraction and Modularity**: Views provide a level of abstraction, allowing developers to work with a simplified representation of the data. This abstraction promotes modularity and code organization, making it easier to understand and maintain the database schema.
- **Security and Access Control**: Views can be used to control access to sensitive data. By granting users access to specific views rather than direct access to underlying tables, developers can restrict which columns or rows users can see. This enhances data security and ensures that users only have access to the information they need.
- **Performance Optimization**: Views can be used to precompute and store the results of complex queries. This can improve query performance by avoiding redundant calculations and aggregations. Additionally, views can be indexed in some databases, further enhancing performance for frequently accessed data.
- **Data Aggregation and Transformation**: Views are valuable for aggregating and transforming data. Developers can create views that present data in a format that is more suitable for reporting and analysis. For example, a view can be created to calculate total sales by region or to summarize customer activity.
- **Code Reusability**: Views promote code reusability by allowing developers to define common queries once and reuse them across multiple applications or reports. This reduces redundancy and ensures consistency in data retrieval.
- **Hiding Complexity**: Views can hide the underlying complexity of the database schema from application developers. This is particularly useful when changes are made to the database structure, but the views remain unchanged, preventing the need for extensive code modifications in applications.
- **Joining Tables**: View simplify the process of joining multiple tables. Instead of writing complex join operations in every query, developers can create a view that encapsulates the join logic, making subsequent queries more straightforward.
- **Versioning and Migration**: Views can be sed as an abstraction layer during database versioning and migration. Developers can update the underlying tables without affecting the queries that rely on the views, minimizing disruptions to applications.

### Implementation

In the following example, we will work with two tables, `players` and `games_played`. The `players` table will contain information about players, and the `games_played` table will contain records of each game played by the players. The `games_played` table will have a foreign key, `player_id`, that references the `players` table to establish a relationship between the two tables.

**players**

| player_id | player_name | player_email              |
| --------- | ----------- | ------------------------- |
| 1         | Tanisi      | cantstopmenow@example.com |
| 2         | Zelda       | mamamia@example.com       |
| 3         | ImmaWinner  | zeldafan@example.com      |

**games_played**

| game_id | player_id | game_title                              | game_score                         |
| ------- | --------- | --------------------------------------- | ---------------------------------- | --- |
| 101     | 1         | The Legend of Zelda: Ocarina of Time    | 95                                 |
| 102     | 1         | The Legend of Zelda: Breath of the Wild | 98                                 |
| 103     | 2         | The Legend of Zelda: Twilight Princess  | 92                                 |
| 104     | 2         |                                         | The Legend of Zelda: Skyward Sword | 88  |
| 105     | 3         | The Legend of Zelda: Wind Waker         | 90                                 |
| 106     | 3         | The Legend of Zelda: A Link to the Past | 94                                 |

Let's consider a scenario where you are tasked with retrieving detailed information about each player along with the games they have played. Assuming we want a view that includes detailed information about each player and the games they have played, we can create a view, `player_games_view`, that joins the `players` and `games_played` tables.

**Syntax to Create the View:**

```sql
CREATE VIEW view_name AS
SELECT column1, column2, ...
FROM table_name
WHERE condition;
```

**Creating the View:**

```sql
-- Create a view to show detailed information about each player and the games they have played
CREATE VIEW player_games_view AS
SELECT p.player_id, p.player_name, p.player_email,
       g.game_id, g.game_title, g.game_score
FROM players p
JOIN games_played g
ON p.player_id = g.player_id;
```

This view encapsulates the logic of joining the `players` and `games_played` tables, providing a simplified interface for querying player and game information.

To see the data in the view, you can perform a `SELECT` query on the view:

```sql
-- Query the view to see player and game information
SELECT * FROM player_games_view;
```

**OUTPUT**

| player_id | player_name | player_email              | game_id | game_title                              | game_score |
| --------- | ----------- | ------------------------- | ------- | --------------------------------------- | ---------- |
| 1         | Tanisi      | cantstopmenow@example.com | 101     | The Legend of Zelda: Ocarina of Time    | 95         |
| 1         | Tanisi      | cantstopmenow@example.com | 102     | The Legend of Zelda: Breath of the Wild | 98         |
| 2         | Zelda       | mamamia@example.com       | 103     | The Legend of Zelda: Twilight Princess  | 92         |
| 2         | Zelda       | mamamia@example.com       | 104     | The Legend of Zelda: Skyward Sword      | 88         |
| 3         | ImmaWinner  | zeldafan@example.com      | 105     | The Legend of Zelda: Wind Waker         | 90         |
| 3         | ImmaWinner  | zeldafan@example.com      | 106     | The Legend of Zelda: A Link to the Past | 94         |

This query retrieves all records from the `player_games_view`, displaying detailed information about each player along with the games they have played. The view simplifies the process of retrieving this information by encapsulating the join logic, making it easier to work with player and game data.
