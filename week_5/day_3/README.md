# JDBC/SQL Intermediate

## Cross Join

A `CROSS JOIN`, commonly known as a `CARTESIAN JOIN`, is a type of join in SQL that returns the Cartesian product of two tables. This means that it combines each row from the first table with every row from the second table, resulting in a set of all possible combinations of rows.

If no condition is provided, the result set is generated by multiplying each row from the first table with each row from the second table. This can lead to a large number of rows in the result set, especially if both tables have many rows.

![Cross Join](cross-join.jpg)

**Syntax:**

```sql
SELECT *
FROM table1
CROSS JOIN table2;
```

### Real World Application

`CROSS JOIN` is used when we need to find all possibilities of combining multiple records, where the result set includes every row from each contributing table. This is particularly useful in scenarios such as:

- Generating all possible combinations of products and customers for a marketing campaign.
- Creating a schedule that pairs every employee with every available project.
- Analyzing the impact of different marketing strategies by combining them with various customer segments.

`CROSS JOIN` can also be used to identify missing relationships or gaps in data by generating all possible combinations and then filtering out the existing relationships.

### Implementation

Let's consider a real world example involving an online store. Below, we have two tables `Customers` and `Products`:

**Customers**

| customerId | f_name  | l_name    |
| ---------- | ------- | --------- |
| 1          | Alice   | May       |
| 2          | Bob     | Parker    |
| 3          | Charlie | Chocolate |

**Products**

| productId | productName | price  |
| --------- | ----------- | ------ |
| 101       | Laptop      | 999.99 |
| 102       | Smartphone  | 499.99 |
| 103       | Headphones  | 79.99  |

Let's generate all possible combinations of customers and products using a `CROSS JOIN`.

```sql
-- Cross join to generate all combinations of customers and products
SELECT Customers.CustomerId, Customers.f_name, Customers.l_name,
       Products.productId, Products.productName, Products.price as ProductPrice
FROM Customers
CROSS JOIN Products;
```

In this example, the `Customers` table represents the store's customers, and the `Products` table represents the available products with their prices. The `CROSS JOIN` generates all possible combinations of customers and products, allowing you to see every customer paired with every product.

**OUTPUT**

| customerId | f_name  | l_name    | productId | productName | ProductPrice |
| ---------- | ------- | --------- | --------- | ----------- | ------------ |
| 1          | Alice   | May       | 101       | Laptop      | 999.99       |
| 1          | Alice   | May       | 102       | Smartphone  | 499.99       |
| 1          | Alice   | May       | 103       | Headphones  | 79.99        |
| 2          | Bob     | Parker    | 101       | Laptop      | 999.99       |
| 2          | Bob     | Parker    | 102       | Smartphone  | 499.99       |
| 2          | Bob     | Parker    | 103       | Headphones  | 79.99        |
| 3          | Charlie | Chocolate | 101       | Laptop      | 999.99       |
| 3          | Charlie | Chocolate | 102       | Smartphone  | 499.99       |
| 3          | Charlie | Chocolate | 103       | Headphones  | 79.99        |

This information can be useful because now we can analyze potential sales opportunities, understand customer preferences, and generate comprehensive reports for marketing strategies.

## Self Join

`SELF JOIN` is a type of join in SQL where a table is joined with itself. This is useful when you want to compare rows within the same table or when you need to find relationships between records in the same table.

When performing a `SELF JOIN`, you typically use table aliases to differentiate between the two instances of the same table. This allows you to reference the same table multiple times in a single query.

This type of join is also known as a Unary relationship.

![Self Join](self-join.jpg)

**Syntax**:

```sql
SELECT a.column1, b.column2
FROM table_name a, table_name b
WHERE a.common_field = b.common_field;
```

### Real World Application

Real world use cases include:

- Finding hierarchical relationships, such as employees and their managers within an organization.
- Comparing records within the same table, such as finding duplicate entries or related items.
- Analyzing relationships in social networks, such as friends or followers.

### Implementation

In the following example, we will have one table since a `SELF JOIN` is a type of join wherein the data is coming from the same table.

**Employees**

| employee_id | employee_name        | manager_id |
| ----------- | -------------------- | ---------- |
| 1           | CEO                  | NULL       |
| 2           | Marketing Manager    | 1          |
| 3           | Sales Manager        | 1          |
| 4           | Marketing Specialist | 2          |
| 5           | Sales Representative | 3          |
| 6           | Marketing Intern     | 2          |

Using the records from this table, we would like to retrieve our employees and readable information for each employee's associated manager in the company.

A `SELF JOIN` query will accomplish this task perfectly:

```sql
SELECT e.employee_name AS employee, m.employee_name AS manager
FROM Employees e
JOIN Employees m
ON e.manager_id = m.employee_id
ORDER BY  e.employee_id;
```

We can also execute the same logic but without the `JOIN` keyword:

```sql
SELECT e.employee_name as employee, m.employee_name as manager
FROM Employees e, Employees m
WHERE e.manager_id = m.employee_id
ORDER BY e.employee_id;
```

**OUTPUT**

| employee             | manager           |
| -------------------- | ----------------- |
| Marketing Manager    | CEO               |
| Sales Manager        | CEO               |
| Marketing Specialist | Marketing Manager |
| Sales Representative | Sales Manager     |
| Marketing Intern     | Marketing Manager |

Both examples utilize a `SELF JOIN` to retrieve related data from the same table. However, the CEO record is not returned from the query due to the `NULL` foreign key reference and the behavior of the `SELF JOIN` or a `WHERE` clause. If we require the CEO record to be returned, we can use a `LEFT JOIN` instead of an `INNER JOIN` or a `WHERE` clause.

```sql
SELECT e.employee_name AS employee, m.employee_name AS manager
FROM Employees e
LEFT JOIN Employees m
ON e.manager_id = m.employee_id
ORDER BY e.employee_id;
```

**OUTPUT**

| employee             | manager           |
| -------------------- | ----------------- |
| CEO                  | NULL              |
| Marketing Manager    | CEO               |
| Sales Manager        | CEO               |
| Marketing Specialist | Marketing Manager |
| Sales Representative | Sales Manager     |
| Marketing Intern     | Marketing Manager |

## Set Operators

Set operators in SQL are used to combine the results of two or more `SELECT` statements into a single result set. The most commonly used set operators are:

- `UNION`: Combines the results of two `SELECT` statements and removes duplicate rows from the result set.
- `UNION ALL`: Combines the results of two `SELECT` statements and includes all rows, including duplicates.
- `INTERSECT`: Returns only the rows that are common to both `SELECT` statements.
- `EXCEPT` (or `MINUS` in some databases): Returns the rows from the first `SELECT` statement that are not present in the second `SELECT` statement.

Two important rules to remember when using set operators:

1. Each `SELECT` statement within the set operator must have the same number of columns in the result sets with similar data types.
2. The columns in each `SELECT` statement must be in the same order.

### Real World Application

Set operators are commonly used by developers to perform operations on sets of data. In the context of databases and SQL, set operators are particularly useful for:

- **Data Retrieval and Filtering**:
  - **UNION**: Developers use `UNION` to combine results from multiple tables or queries, especially when they want to eliminate duplicate records. For example, when retrieving a list of unique customers from different regions.
  - **INTERSECT**: The `INTERSECT` operator is useful for finding common records between two datasets, such as identifying customers who have made purchases in both the current and previous years.
  - **EXCEPT (or MINUS in some databases)**: The `EXCEPT` operator(`MINUS` in some databases) is used to find records that exist in one dataset but not in another, such as identifying customers who have not made any purchases in the last month.
- **Data Cleaning and Deduplication**: Set operators, especially `UNION`, are valuable for data cleaning tasks and deduplication. By combining datasets and removing duplicates, developers can ensure that their data is accurate and consistent.
- **Complex Queries**: Set operators enable developers to construct complex queries by combining multiple sets of data. This is useful for generating reports, analytics, and insights from various sources.
- **Optimizing Queries**: Set operators can be used to optimize queries by breaking down complex queries into smaller, more manageable parts. This can improve query performance and make it easier to understand and maintain the code.
- **Logical Operations**: Set operators mimic logical operations on sets, allowing developers to express complex conditions and relationships between datasets in a clear and concise manner. For example, using `INTERSECT` to find commonalities or `EXCEPT` to identify differences between datasets.
- **Data Analysis and Reporting**: In scenarios where developers need to analyze data from different sources or generate reports that involve merging or comparing datasets, set operators provide a convenient way to achieve this.

Set operators, particularly in databases, help developers manipulate and analyze sets of data efficiently, enabling them to perform tasks such as data retrieval, filtering, cleaning, and complex querying.

### Implementation

Let's consider two tables, `businesses` and `sales`, to demonstrate the use of set operators.

**businesses**

| business_id | business_name         |
| ----------- | --------------------- |
| 1           | Fashion Excess Cloths |
| 2           | High Fashion Shoes    |

**sales**

| sale_id | business_id | product_id | quantity | total_amount |
| ------- | ----------- | ---------- | -------- | ------------ | ------ |
| 1       | 1           | 101        | 3        | 300.00       |
| 2       | 1           | 102        | 2        | 200.00       |
| 3       | 2           | 101        | 5        | 500.00       |
| 4       | 2           | 103        | 4        |              | 400.00 |

#### UNION

The SQl `UNION` operator merges the result sets of multiple `SELECT` statements into a single result set, removing duplicate rows. Ensure that the number of columns and their data types match in each `SELECT` statement. For instance, a `SELECT` with 2 columns cannot be combined with a `SELECT` that has 3 columns.

```sql
-- UNION: Get a combined list of all unique products sold across businesses
SELECT product_id
FROM (
  SELECT product_id FROM sales
  WHERE business_id IN (
    SELECT business_id FROM businesses
    UNION
    SELECT product_id FROM sales
  ) as union_results;
)
```

A list of unique product IDs sold across all businesses is returned and duplicates are removed.

The subquery before `UNION` selects the products with the `product_id` of `101`, `102`, and `103` from the `sales` table. The `UNION` operator combines these results, ensuring that each product ID appears only once in the final output.

**OUTPUT**

| product_id |
| ---------- |
| 101        |
| 102        |
| 103        |

If you wanted to include duplicate records, you could use `UNION ALL` instead of `UNION`.

```sql
-- UNION ALL: Get a combined list of all products sold across businesses, including duplicates
SELECT product_id
FROM (
  SELECT product_id FROM sales
  WHERE business_id IN (
    SELECT business_id FROM businesses
    UNION ALL
    SELECT product_id FROM sales
  ) as union_all_results;
)
```

`UNION ALL` differs from `UNION` in that it does not remove duplicate rows. Therefore, if a product appears multiple times in the individual `SELECT` statements, it will appear multiple times in the final result set.

**OUTPUT**

| product_id |
| ---------- |
| 101        |
| 102        |
| 101        |
| 101        |
| 102        |
| 101        |
| 103        |

#### INTERSECT

The SQL `INTERSECT` operator retrieves only the rows that are common to both `SELECT` statements. It returns the intersection of the two result sets, meaning it includes only those rows that appear in both queries. Similar to `UNION`, the number of columns and their data types must match in each `SELECT` statement.

Note: MySQL **does not** support the `INTERSECT` operator. However, you can achieve similar functionality using `INNER JOIN` or `IN` clause. Always refer to your specific database documentation for supported features.

```sql
-- INTERSECT: Get a list of products sold in common by both businesses
SELECT product_id
FROM (
  SELECT product_id FROM sales
  WHERE business_id = 1
  INTERSECT
  SELECT product_id FROM sales
  WHERE business_id = 2
) AS intersect_results;
```

The query retrieves a list of product IDs that are sold by both businesses. The subquery before `INTERSECT` selects the products sold by business with `business_id` 1, and the second subquery selects the products sold by business with `business_id` 2. The `INTERSECT` operator then returns only those product IDs that are present in both result sets.

**OUTPUT**

| product_id |
| ---------- |
| 101        |

#### EXCEPT (or MINUS)

The SQL `EXCEPT` operator (or `MINUS` in some databases) retrieves rows from the first `SELECT` statement that are not present in the second `SELECT` statement. It returns the difference between the two result sets, meaning it includes only those rows that exist in the first query but not in the second. As with other set operators, the number of columns and their data types must match in each `SELECT` statement.

Note: The `MINUS` operator, found in some databases, is functionally equivalent to `EXCEPT`. For example, in PostgreSQL or Oracle, you an replace `EXCEPT` with `MINUS` to achieve the same result. Always refer to your specific database documentation for supported features.

```sql
--  EXCEPT: Get a list of products sold by business 1 but not by business 2
SELECT product_id
FROM (
  SELECT product_id FROM sales
  WHERE business_id = 1
  EXCEPT
  SELECT product_id FROM sales
  WHERE business_id = 2
) AS except_results;
```

The query retrieves a list of product IDs that are sold by business with `business_id` 1 but not by business with `business_id` 2. The subquery before `EXCEPT` selects the products sold by business 1, and the second subquery selects the products sold by business 2. The `EXCEPT` operator then returns only those product IDs that are present in the first result set but not in the second.

**OUTPUT**

| product_id |
| ---------- |
| 102        |
